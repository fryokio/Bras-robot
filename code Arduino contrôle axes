// ‚úÖ D√©finition des Pins pour les 4 Axes (CNC Shield)
#define STEP_X 2  
#define DIR_X 5   
#define STEP_Y 3  
#define DIR_Y 6   
#define STEP_Z 4  
#define DIR_Z 7   
#define STEP_A 12  
#define DIR_A 13   
#define EN 8  // Pin ENABLE des drivers (LOW = actif, HIGH = d√©sactiv√©)

// ‚úÖ Param√®tres m√©caniques
const float transmissionRatio = 1.7778;  // ‚úÖ Rapport de transmission 80/45
const int stepsPerRevolution = 400; // ‚úÖ Nombre de pas pour 1 tour moteur en Half Step
const int correctedStepsPerRevolution = stepsPerRevolution * transmissionRatio; // ‚úÖ Nombre de pas pour 1 tour de sortie

// ‚úÖ Param√®tres d'acc√©l√©ration et de d√©c√©l√©ration
const int minDelay = 2500;  
const int maxSpeedDelay = 1000;  
const int accelerationSteps = correctedStepsPerRevolution / 3; 

// ‚úÖ Variables de contr√¥le
char selectedAxis = 'X';  // ‚úÖ Axe par d√©faut
bool startRotation = false;
float targetAngle = 0;
bool stopCommand = false;
bool reglageMode = false; // ‚úÖ Mode R√©glage d√©sactiv√© par d√©faut

// ‚úÖ Pointeurs de l‚Äôaxe s√©lectionn√©
int stepPin = STEP_X;
int dirPin = DIR_X;

void setup() {
  // ‚úÖ Initialisation des Pins
  pinMode(STEP_X, OUTPUT);
  pinMode(DIR_X, OUTPUT);
  pinMode(STEP_Y, OUTPUT);
  pinMode(DIR_Y, OUTPUT);
  pinMode(STEP_Z, OUTPUT);
  pinMode(DIR_Z, OUTPUT);
  pinMode(STEP_A, OUTPUT);
  pinMode(DIR_A, OUTPUT);
  pinMode(EN, OUTPUT);

  digitalWrite(EN, LOW); // Active les drivers

  Serial.begin(115200);
  Serial.println("Moteur optimis√© avec s√©lection de l'axe et mode r√©glage.");
  Serial.println("Commandes disponibles :");
  Serial.println("AXE=X, AXE=Y, AXE=Z, AXE=A ‚Üí S√©lectionne l'axe");
  Serial.println("START ‚Üí Effectuer 1 tour");
  Serial.println("STOP ‚Üí Annuler une rotation");
  Serial.println("ANGLE=XX ‚Üí D√©placer de XX degr√©s");
  Serial.println("REGLAGE=ON ‚Üí Teste le moteur en rotation continue");
  Serial.println("REGLAGE=OFF ‚Üí Arr√™te le mode r√©glage");
}

void loop() {
  checkSerialCommands(); // ‚úÖ V√©rifie les commandes du Serial Monitor

  if (reglageMode) {
    testMotor(); // ‚úÖ Mode de r√©glage actif
  } 
  else if (startRotation) {
    rotateToAngle(targetAngle);
    startRotation = false;
  }
}

// üîπ V√©rifie les commandes re√ßues via le Serial Monitor
void checkSerialCommands() {
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    command.trim();

    if (command.startsWith("AXE=")) {
      char axis = command.charAt(4);
      selectAxis(axis);
    } 
    else if (command == "START") {
      if (!reglageMode) {
        startRotation = true;
        targetAngle = 360;
        Serial.print("D√©marrage d'un tour sur l'axe ");
        Serial.println(selectedAxis);
      }
    } 
    else if (command == "STOP") {
      stopCommand = true;
      Serial.println("Rotation stopp√©e.");
    } 
    else if (command.startsWith("ANGLE=")) {
      if (!reglageMode) {
        targetAngle = command.substring(6).toFloat();
        targetAngle = constrain(targetAngle, 0, 360);
        startRotation = true;
        Serial.print("D√©marrage d'une rotation de ");
        Serial.print(targetAngle);
        Serial.print(" degr√©s sur l'axe ");
        Serial.println(selectedAxis);
      }
    } 
    else if (command == "REGLAGE=ON") {
      reglageMode = true;
      Serial.println("Mode R√©glage activ√© : rotation continue pour tester `Vref`.");
    } 
    else if (command == "REGLAGE=OFF") {
      reglageMode = false;
      Serial.println("Mode R√©glage d√©sactiv√©.");
    } 
    else {
      Serial.println("Commande invalide. Utilisez AXE=X, START, STOP, ANGLE=XX, REGLAGE=ON/OFF.");
    }
  }
}

// üîπ S√©lectionne l‚Äôaxe actif
void selectAxis(char axis) {
  switch (axis) {
    case 'X':
      stepPin = STEP_X;
      dirPin = DIR_X;
      selectedAxis = 'X';
      break;
    case 'Y':
      stepPin = STEP_Y;
      dirPin = DIR_Y;
      selectedAxis = 'Y';
      break;
    case 'Z':
      stepPin = STEP_Z;
      dirPin = DIR_Z;
      selectedAxis = 'Z';
      break;
    case 'A':
      stepPin = STEP_A;
      dirPin = DIR_A;
      selectedAxis = 'A';
      break;
    default:
      Serial.println("Axe invalide. Choisissez AXE=X, AXE=Y, AXE=Z ou AXE=A.");
      return;
  }
  Serial.print("Axe s√©lectionn√© : ");
  Serial.println(selectedAxis);
}

// üîπ Mode R√©glage : rotation continue pour ajuster `Vref`
void testMotor() {
  singleStep(1500); // ‚úÖ Le moteur tourne en continu avec un d√©lai optimis√©
}

// üîπ Effectue une rotation sur l‚Äôaxe s√©lectionn√©
void rotateToAngle(float angle) {
  int stepsToMove = (angle / 360.0) * correctedStepsPerRevolution;

  // ‚úÖ Acc√©l√©ration progressive
  for (int i = 0; i < accelerationSteps && i < stepsToMove; i++) {
    if (stopCommand) return;
    int delayTime = map(i, 0, accelerationSteps, minDelay, maxSpeedDelay);
    singleStep(delayTime);
  }

  // ‚úÖ Mouvement stabilis√©
  for (int i = 0; i < (stepsToMove - 2 * accelerationSteps); i++) {
    if (stopCommand) return;
    singleStep(maxSpeedDelay);
  }

  // ‚úÖ D√©c√©l√©ration progressive
  for (int i = 0; i < accelerationSteps && i < stepsToMove; i++) {
    if (stopCommand) return;
    int delayTime = map(i, 0, accelerationSteps, maxSpeedDelay, minDelay);
    singleStep(delayTime);
  }

  Serial.println("Rotation termin√©e.");
  stopCommand = false;
}

// üîπ G√®re chaque pas avec un d√©lai variable
void singleStep(int delayTime) {
  digitalWrite(stepPin, HIGH);
  delayMicroseconds(delayTime);
  digitalWrite(stepPin, LOW);
  delayMicroseconds(delayTime);
}
